#include "SDL.h"

#include "RichTextString.h"
#include "../Media/FontLibrary.h"
#include "../Media/FontUtils.h"

#include "components/utilities/String.h"

RichTextString::RichTextString(const std::string &text, FontName fontName,
	const Color &color, TextAlignment alignment, int lineSpacing, const FontLibrary &fontLibrary)
	: text(text), fontName(fontName), color(color), alignment(alignment),
	lineSpacing(lineSpacing)
{
	// Get the font associated with the font name.
	const char *fontNameStr = FontUtils::fromName(fontName);
	int fontIndex;
	if (!fontLibrary.tryGetDefinitionIndex(fontNameStr, &fontIndex))
	{
		DebugCrash("Couldn't get font index \"" + std::string(fontNameStr) + "\".");
	}

	const FontDefinition &fontDef = fontLibrary.getDefinition(fontIndex);
	this->characterHeight = fontDef.getCharacterHeight();

	// Get the font characters associated with each line of text.
	this->characterLists = [&text, &fontDef]()
	{
		// Split the text on each newline. If the text is empty, then just add a space, 
		// so there doesn't need to be any "zero-character" special case.
		const std::vector<std::string> textLines =
			String::split((text.size() > 0) ? text : std::string(" "), '\n');

		std::vector<std::vector<FontDefinition::CharID>> tempLists;

		// Go through each line of text and get the associated font characters.
		for (const std::string &textLine : textLines)
		{
			std::vector<FontDefinition::CharID> charIDs;
			for (const char c : textLine)
			{
				const std::string charUtf8(1, c);
				FontDefinition::CharID charID;
				if (!fontDef.tryGetCharacterID(charUtf8.c_str(), &charID))
				{
					DebugLogWarning("Couldn't get font character ID for \"" + charUtf8 + "\".");
					continue;
				}

				charIDs.push_back(charID);
			}

			tempLists.push_back(std::move(charIDs));
		}

		return tempLists;
	}();

	// Get the width of each line in pixels, for determining the longest line.
	this->lineWidths = [this, &fontDef]()
	{
		std::vector<int> widths;
		for (const std::vector<FontDefinition::CharID> &charIDs : this->characterLists)
		{
			// Start a new count on the line widths.
			widths.push_back(0);

			// Get the combined widths for the current line's characters.
			for (const FontDefinition::CharID charID : charIDs)
			{
				const FontDefinition::Character &character = fontDef.getCharacter(charID);
				widths.back() += character.getWidth();
			}
		}

		return widths;
	}();

	// Get the width and height for the texture (generated by a text box).
	this->dimensions = [this, lineSpacing]()
	{
		// Get the width in pixels for the texture.
		const int textureWidth = [this]()
		{
			// Get the width in pixels of the longest line.
			int maxWidth = 0;
			for (const int lineWidth : this->lineWidths)
			{
				if (lineWidth > maxWidth)
				{
					maxWidth = lineWidth;
				}
			}
			return maxWidth;
		}();

		// Get the height in pixels for the texture. Also include line spacing.
		const int lineCount = static_cast<int>(this->characterLists.size());
		const int textureHeight = (this->characterHeight * lineCount) +
			(lineSpacing * (lineCount - 1));

		return Int2(textureWidth, textureHeight);
	}();
}

RichTextString::RichTextString(const std::string &text, FontName fontName,
	const Color &color, TextAlignment alignment, const FontLibrary &fontLibrary)
	: RichTextString(text, fontName, color, alignment, 0, fontLibrary) { }

const std::vector<std::vector<FontDefinition::CharID>> &RichTextString::getCharacterLists() const
{
	return this->characterLists;
}

const std::vector<int> &RichTextString::getLineWidths() const
{
	return this->lineWidths;
}

const std::string &RichTextString::getText() const
{
	return this->text;
}

FontName RichTextString::getFontName() const
{
	return this->fontName;
}

const Color &RichTextString::getColor() const
{
	return this->color;
}

const Int2 &RichTextString::getDimensions() const
{
	return this->dimensions;
}

TextAlignment RichTextString::getAlignment() const
{
	return this->alignment;
}

int RichTextString::getLineSpacing() const
{
	return this->lineSpacing;
}

int RichTextString::getCharacterHeight() const
{
	return this->characterHeight;
}
